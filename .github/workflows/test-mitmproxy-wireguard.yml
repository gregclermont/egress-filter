name: Test mitmproxy transparent

on:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libnetfilter-queue-dev libnfnetlink-dev

      - name: Install dependencies
        run: uv sync

      - name: Cache BPF objects
        id: bpf-cache
        uses: actions/cache@v4
        with:
          path: src/bpf/*.bpf.o
          key: bpf-${{ hashFiles('src/bpf/*.bpf.c') }}

      - name: Compile BPF programs
        if: steps.bpf-cache.outputs.cache-hit != 'true'
        run: |
          docker run --rm -v "$(pwd)":/src ghcr.io/gregclermont/tinybpf-compile src/bpf/port_tracker.bpf.c

      - name: Setup mitmproxy transparent mode with BPF tracking
        run: |
          set -e

          # Cleanup iptables on failure to avoid breaking runner communication
          cleanup() {
            sudo iptables -t mangle -F 2>/dev/null || true
            sudo iptables -t nat -F 2>/dev/null || true
            sudo iptables -t filter -F 2>/dev/null || true
            sudo ip6tables -t nat -F 2>/dev/null || true
          }
          trap cleanup ERR

          # Start unified proxy as root (needed for BPF), exclude root's traffic via iptables
          echo "Starting unified proxy..."
          sudo env PROXY_LOG_FILE=/tmp/proxy.log \
            $(pwd)/.venv/bin/python unified_proxy.py > /tmp/proxy-stdout.log 2>&1 &
          PROXY_PID=$!

          # Wait for proxy to be listening
          counter=0
          while ! sudo ss -tln | grep -q ':8080 '; do
            sleep 1
            counter=$((counter+1))
            if ! sudo kill -0 $PROXY_PID 2>/dev/null; then
              echo "Proxy process died! Output:"
              cat /tmp/proxy-stdout.log || true
              exit 1
            fi
            if [ $counter -gt 10 ]; then
              echo "Timeout waiting for proxy"
              exit 1
            fi
          done
          echo "Proxy listening on port 8080"

          # Setup iptables - exclude root's traffic to prevent loops
          sudo sysctl -w net.ipv4.ip_forward=1
          sudo sysctl -w net.ipv6.conf.all.forwarding=1
          sudo sysctl -w net.ipv4.conf.all.send_redirects=0

          # ===========================================
          # Block direct proxy connections
          # ===========================================
          # Prevent apps from bypassing transparent redirect by connecting
          # directly to the proxy ports. Without this, apps could connect to
          # localhost:8080 or :8053 directly, and we'd lose visibility into
          # the original destination they intended to reach.
          # Mark in mangle (before nat), drop in filter.
          sudo iptables -t mangle -A OUTPUT -p tcp -d 127.0.0.1 --dport 8080 -m owner ! --uid-owner 0 -j MARK --set-mark 1
          sudo iptables -t mangle -A OUTPUT -p udp -d 127.0.0.1 --dport 8053 -m owner ! --uid-owner 0 -j MARK --set-mark 1
          sudo iptables -A OUTPUT -m mark --mark 1 -j DROP

          # ===========================================
          # UDP: nfqueue for DNS detection + PID tracking
          # ===========================================
          # Flow:
          #   All UDP → nfqueue (mangle, before NAT)
          #                 ↓
          #           haslayer(DNS)?
          #            /        \
          #          yes         no
          #           ↓           ↓
          #      mark=2        (just log)
          #      cache 4-tuple
          #           ↓
          #      nat: mark=2 → REDIRECT :8053
          #           ↓
          #      mitmproxy
          #
          # Exclude systemd-resolve: it's the system DNS stub resolver that
          # forwards queries to upstream DNS. Must reach network directly.
          sudo iptables -t mangle -A OUTPUT -p udp -m owner --uid-owner systemd-resolve -j RETURN
          # Exclude root (uid 0): mitmproxy runs as root. Without this exclusion,
          # mitmproxy's own DNS queries would loop back through nfqueue → mitmproxy.
          sudo iptables -t mangle -A OUTPUT -p udp -m owner --uid-owner 0 -j RETURN
          # Everything else → nfqueue for inspection
          sudo iptables -t mangle -A OUTPUT -p udp -j NFQUEUE --queue-num 1

          # ===========================================
          # TCP: transparent proxy (8080)
          # ===========================================
          # Exclude root: mitmproxy runs as root and makes outbound connections
          # to upstream servers. Without this, infinite redirect loop.
          sudo iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner 0 -j RETURN
          sudo iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 8080
          # IPv6 (note: blocked by BPF, but keep rules for completeness)
          sudo ip6tables -t nat -A OUTPUT -p tcp -m owner --uid-owner 0 -j RETURN
          sudo ip6tables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 8080

          # ===========================================
          # DNS: redirect marked packets (8053)
          # ===========================================
          # nfqueue inspects UDP packets and sets mark=2 on DNS (by structure,
          # not port - catches DNS on non-standard ports too)
          sudo iptables -t nat -A OUTPUT -p udp -m mark --mark 2 -j REDIRECT --to-port 8053
          sudo ip6tables -t nat -A OUTPUT -p udp -m mark --mark 2 -j REDIRECT --to-port 8053

          # Install mitmproxy certificate as system CA
          sudo mkdir -p /usr/local/share/ca-certificates/extra
          sudo openssl x509 -in /root/.mitmproxy/mitmproxy-ca-cert.pem -inform PEM -out /tmp/mitmproxy-ca-cert.crt
          sudo cp /tmp/mitmproxy-ca-cert.crt /usr/local/share/ca-certificates/extra/mitmproxy-ca-cert.crt
          sudo dpkg-reconfigure -p critical ca-certificates
          sudo update-ca-certificates

          # Set CA env vars for tools that don't use system store (copy to readable location)
          sudo cp /root/.mitmproxy/mitmproxy-ca-cert.pem /tmp/mitmproxy-ca-cert.pem
          sudo chmod 644 /tmp/mitmproxy-ca-cert.pem
          echo "NODE_EXTRA_CA_CERTS=/tmp/mitmproxy-ca-cert.pem" >> $GITHUB_ENV
          echo "REQUESTS_CA_BUNDLE=/tmp/mitmproxy-ca-cert.pem" >> $GITHUB_ENV

          echo "--all done--"

      - name: Test connectivity through proxy
        run: |
          echo "Testing HTTP..."
          curl -v http://example.com 2>&1 | head -20

          echo "Testing HTTPS..."
          curl -v https://example.com 2>&1 | head -20

          echo "Testing with wget..."
          wget -O /dev/null https://httpbin.org/get

          echo "Testing non-HTTP TCP (SSH to github.com)..."
          echo "" | nc -v github.com 22 2>&1 | head -5 || true

          echo "Testing DNS..."
          dig +short example.com

          echo "All connectivity tests passed!"

      - name: Run comprehensive PID tracking tests
        run: |
          # This test suite always exits 0 - it's for observability
          # and tracking which edge cases work vs don't work
          PROXY_LOG_FILE=/tmp/proxy.log ./tests/test_pid_tracking.sh

      - name: Stop proxy gracefully
        if: always()
        run: |
          # Send SIGTERM to trigger shutdown
          sudo pkill -TERM -f "python unified_proxy.py" || true
          sleep 2

      - name: Cleanup iptables
        if: always()
        run: |
          # Flush all tables we modified
          sudo iptables -t mangle -F 2>/dev/null || true
          sudo iptables -t nat -F 2>/dev/null || true
          sudo iptables -t filter -F 2>/dev/null || true
          sudo ip6tables -t nat -F 2>/dev/null || true

      - name: Show proxy logs
        if: always()
        run: |
          echo "=== Proxy Log (custom) ==="
          cat /tmp/proxy.log || echo "No log file found"
          echo ""
          echo "=== Proxy stdout/stderr ==="
          cat /tmp/proxy-stdout.log || echo "No log file found"
          echo ""
          echo "=== Mitmproxy Log (debug) ==="
          cat /tmp/mitmproxy.log || echo "No log file found"
