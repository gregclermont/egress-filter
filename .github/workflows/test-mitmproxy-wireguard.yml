name: Test mitmproxy transparent

on:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install dependencies
        run: uv sync

      - name: Cache BPF objects
        id: bpf-cache
        uses: actions/cache@v4
        with:
          path: src/bpf/*.bpf.o
          key: bpf-${{ hashFiles('src/bpf/*.bpf.c') }}

      - name: Compile BPF programs
        if: steps.bpf-cache.outputs.cache-hit != 'true'
        run: docker run --rm -v "$(pwd)":/src ghcr.io/gregclermont/tinybpf-compile src/bpf/port_tracker.bpf.c

      - name: Setup mitmproxy transparent mode with BPF tracking
        run: |
          set -e

          # Cleanup iptables on failure to avoid breaking runner communication
          cleanup() {
            sudo iptables -t nat -F 2>/dev/null || true
            sudo ip6tables -t nat -F 2>/dev/null || true
          }
          trap cleanup ERR

          # Start unified proxy as root (needed for BPF), exclude root's traffic via iptables
          echo "Starting unified proxy..."
          sudo env PROXY_LOG_FILE=/tmp/proxy.log \
            $(pwd)/.venv/bin/python unified_proxy.py > /tmp/proxy-stdout.log 2>&1 &
          PROXY_PID=$!

          # Wait for proxy to be listening
          counter=0
          while ! sudo ss -tln | grep -q ':8080 '; do
            sleep 1
            counter=$((counter+1))
            if ! sudo kill -0 $PROXY_PID 2>/dev/null; then
              echo "Proxy process died! Output:"
              cat /tmp/proxy-stdout.log || true
              exit 1
            fi
            if [ $counter -gt 10 ]; then
              echo "Timeout waiting for proxy"
              exit 1
            fi
          done
          echo "Proxy listening on port 8080"

          # Setup iptables - exclude root's traffic to prevent loops
          sudo sysctl -w net.ipv4.ip_forward=1
          sudo sysctl -w net.ipv6.conf.all.forwarding=1
          sudo sysctl -w net.ipv4.conf.all.send_redirects=0
          # TCP -> transparent proxy (8080)
          sudo iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner 0 -j RETURN
          sudo iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 8080
          sudo ip6tables -t nat -A OUTPUT -p tcp -m owner --uid-owner 0 -j RETURN
          sudo ip6tables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 8080

          # DNS (UDP 53) -> dns proxy (8053)
          # Allow systemd-resolved to reach upstream DNS
          sudo iptables -t nat -A OUTPUT -p udp --dport 53 -m owner --uid-owner systemd-resolve -j RETURN
          # Allow mitmproxy (root) to query systemd-resolved on localhost
          sudo iptables -t nat -A OUTPUT -p udp --dport 53 -d 127.0.0.53 -m owner --uid-owner 0 -j RETURN
          # Redirect everything else to mitmproxy DNS
          sudo iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-port 8053
          # Same for IPv6
          sudo ip6tables -t nat -A OUTPUT -p udp --dport 53 -m owner --uid-owner systemd-resolve -j RETURN
          sudo ip6tables -t nat -A OUTPUT -p udp --dport 53 -d ::1 -m owner --uid-owner 0 -j RETURN
          sudo ip6tables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-port 8053

          # Install mitmproxy certificate as system CA
          sudo mkdir -p /usr/local/share/ca-certificates/extra
          sudo openssl x509 -in /root/.mitmproxy/mitmproxy-ca-cert.pem -inform PEM -out /tmp/mitmproxy-ca-cert.crt
          sudo cp /tmp/mitmproxy-ca-cert.crt /usr/local/share/ca-certificates/extra/mitmproxy-ca-cert.crt
          sudo dpkg-reconfigure -p critical ca-certificates
          sudo update-ca-certificates

          # Set CA env vars for tools that don't use system store (copy to readable location)
          sudo cp /root/.mitmproxy/mitmproxy-ca-cert.pem /tmp/mitmproxy-ca-cert.pem
          sudo chmod 644 /tmp/mitmproxy-ca-cert.pem
          echo "NODE_EXTRA_CA_CERTS=/tmp/mitmproxy-ca-cert.pem" >> $GITHUB_ENV
          echo "REQUESTS_CA_BUNDLE=/tmp/mitmproxy-ca-cert.pem" >> $GITHUB_ENV

          echo "--all done--"

      - name: Test connectivity through proxy
        run: |
          echo "Testing HTTP..."
          curl -v http://example.com 2>&1 | head -20

          echo "Testing HTTPS..."
          curl -v https://example.com 2>&1 | head -20

          echo "Testing with wget..."
          wget -O /dev/null https://httpbin.org/get

          echo "Testing non-HTTP TCP (SSH to github.com)..."
          echo "" | nc -v github.com 22 2>&1 | head -5 || true

          echo "Testing DNS..."
          dig +short example.com

          echo "All connectivity tests passed!"

      - name: Run comprehensive PID tracking tests
        run: |
          # This test suite always exits 0 - it's for observability
          # and tracking which edge cases work vs don't work
          PROXY_LOG_FILE=/tmp/proxy.log ./tests/test_pid_tracking.sh

      - name: Stop proxy gracefully
        if: always()
        run: |
          # Send SIGTERM to trigger shutdown
          sudo pkill -TERM -f "python unified_proxy.py" || true
          sleep 2

      - name: Cleanup iptables
        if: always()
        run: |
          sudo iptables -t nat -F 2>/dev/null || true
          sudo ip6tables -t nat -F 2>/dev/null || true

      - name: Show proxy logs
        if: always()
        run: |
          echo "=== Proxy Log (custom) ==="
          cat /tmp/proxy.log || echo "No log file found"
          echo ""
          echo "=== Proxy stdout/stderr ==="
          cat /tmp/proxy-stdout.log || echo "No log file found"
          echo ""
          echo "=== Mitmproxy Log (debug) ==="
          cat /tmp/mitmproxy.log || echo "No log file found"

      - name: Upload proxy logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: proxy-logs
          path: |
            /tmp/proxy.log
            /tmp/proxy-stdout.log
            /tmp/mitmproxy.log
          if-no-files-found: warn
