name: Test sfw-free compatibility

on:
  push:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Setup egress filter
        uses: gregclermont/egress-filter@sfw

      - name: Install sfw-free
        if: false  # Skip for now
        run: npm install -g sfw

      - name: Use sfw to install a package
        if: false  # Skip for now
        run: |
          mkdir test-project && cd test-project
          npm init -y
          sfw npm install is-odd

      - name: Verify installation
        if: false  # Skip for now
        run: |
          cd test-project
          node -e "console.log('is-odd(3):', require('is-odd')(3))"

      - name: Test malware blocking
        if: false  # Skip for now
        run: |
          cd test-project
          echo "Attempting to install known malware package (should be blocked)..."
          # atg-atgse is a known malware package (data exfiltration)
          if npm install atg-atgse@1.0.0 2>&1; then
            echo "ERROR: Malware package was NOT blocked!"
            exit 1
          else
            echo "Package was blocked as expected"
          fi

      - name: Verify blocking in logs
        if: false  # Skip for now
        run: |
          echo "Checking proxy logs for SECURITY BLOCKED message..."
          grep -q "SECURITY BLOCKED" /tmp/proxy.log || {
            echo "ERROR: No SECURITY BLOCKED message found in proxy logs"
            cat /tmp/proxy.log
            exit 1
          }
          echo "Found SECURITY BLOCKED message"
          grep "SECURITY BLOCKED" /tmp/proxy.log

      - name: Test Cargo package security check
        if: false  # Skip for now
        run: |
          mkdir -p cargo-test && cd cargo-test
          # Create minimal Cargo.toml
          cat > Cargo.toml << 'CARGO_EOF'
          [package]
          name = "test"
          version = "0.1.0"
          edition = "2021"

          [dependencies]
          itoa = "1.0.0"
          CARGO_EOF
          mkdir -p src && echo 'fn main() {}' > src/main.rs
          # Fetch dependencies (this triggers crates.io download)
          cargo fetch 2>&1 || true

      - name: Verify Cargo security check in logs
        if: false  # Skip for now
        run: |
          echo "Checking proxy logs for Cargo security check..."
          grep -q "SECURITY checking pkg:cargo" /tmp/proxy.log || {
            echo "WARNING: No Cargo security check found in logs"
            echo "This may be expected if cargo uses a different download method"
          }
          grep "SECURITY checking pkg:cargo" /tmp/proxy.log || echo "(no cargo checks found)"
          grep "crates.io\|static.crates.io" /tmp/proxy.log | head -10 || echo "(no crates.io requests found)"

      - name: Test raw Python requests (baseline)
        if: false  # Skip to reduce noise - focus on Poetry
        run: |
          # Test that Python requests works through the proxy
          python3 -c "
          import requests
          print('Testing raw requests library...')
          r = requests.get('https://pypi.org/simple/requests/')
          print(f'Status: {r.status_code}')
          print(f'Content-Length: {len(r.content)}')
          print('Raw requests: OK')
          "

      - name: Test CacheControlAdapter (diagnose Poetry issue)
        if: false  # Skip - Poetry 2.x uses httpx now
        run: |
          # Use venv to avoid permission issues
          python3 -m venv /tmp/test-venv
          /tmp/test-venv/bin/pip install cachecontrol requests
          /tmp/test-venv/bin/python -c "
          import requests
          from cachecontrol import CacheControlAdapter
          import time

          print('Testing CacheControlAdapter...')
          session = requests.Session()
          adapter = CacheControlAdapter()
          session.mount('http://', adapter)
          session.mount('https://', adapter)

          # Test single request
          r = session.get('https://pypi.org/simple/requests/')
          print(f'Single request - Status: {r.status_code}, Length: {len(r.content)}')

          # Test multiple rapid requests (like Poetry does)
          print('Testing multiple rapid requests...')
          for i in range(6):
              try:
                  # Force new session to simulate Poetry's retry behavior
                  session2 = requests.Session()
                  session2.mount('https://', CacheControlAdapter())
                  r2 = session2.get('https://pypi.org/simple/requests/', timeout=5)
                  print(f'Request {i+1}: Status {r2.status_code}')
              except Exception as e:
                  print(f'Request {i+1}: FAILED - {e}')
          print('CacheControlAdapter: OK')
          "

      - name: Test httpx (Poetry 2.x uses httpx)
        if: false  # Skip - not used by Poetry's HTTP layer
        run: |
          python3 -m venv /tmp/httpx-venv
          /tmp/httpx-venv/bin/pip install httpx
          /tmp/httpx-venv/bin/python << 'HTTPX_TEST'
          import httpx
          import sys
          import os

          def log(msg):
              print(msg, flush=True)

          log(f'httpx version: {httpx.__version__}')
          log(f'SSL_CERT_FILE: {os.environ.get("SSL_CERT_FILE", "not set")}')

          # Test 1: Single request with default SSL
          log('Test 1: Single request with default SSL context...')
          try:
              r = httpx.get('https://pypi.org/simple/requests/', timeout=10)
              log(f'  Result: Status={r.status_code}, Length={len(r.content)}')
          except Exception as e:
              log(f'  Result: FAILED - {type(e).__name__}: {e}')
              sys.exit(1)

          # Test 2: Using Client (like Poetry does)
          log('Test 2: Using httpx.Client...')
          try:
              with httpx.Client(timeout=10) as client:
                  r = client.get('https://pypi.org/simple/requests/')
                  log(f'  Result: Status={r.status_code}, Length={len(r.content)}')
          except Exception as e:
              log(f'  Result: FAILED - {type(e).__name__}: {e}')

          log('httpx: ALL TESTS PASSED')
          HTTPX_TEST

      - name: Test Poetry-style requests (CacheControlAdapter + session.send)
        if: false  # Skip to reduce noise - this test passes, focus on actual Poetry
        run: |
          python3 -m venv /tmp/poetry-test-venv
          /tmp/poetry-test-venv/bin/pip install -q requests cachecontrol[filecache]
          /tmp/poetry-test-venv/bin/python << 'POETRY_HTTP_TEST'
          import requests
          from cachecontrol import CacheControlAdapter
          from cachecontrol.caches import FileCache
          import sys
          import os
          import tempfile

          def log(msg):
              print(msg, flush=True)

          log('Testing Poetry-style HTTP requests...')
          log(f'REQUESTS_CA_BUNDLE: {os.environ.get("REQUESTS_CA_BUNDLE", "not set")}')
          log(f'SSL_CERT_FILE: {os.environ.get("SSL_CERT_FILE", "not set")}')

          # Create session like Poetry does (with FileCache AND pool_maxsize!)
          cache_dir = tempfile.mkdtemp(prefix='poetry-cache-')
          log(f'Using cache dir: {cache_dir}')
          session = requests.Session()
          session.headers['User-Agent'] = 'poetry/2.3.1 CPython/3.12.3 Linux/6.11.0-1018-azure'
          file_cache = FileCache(cache_dir)
          # Poetry uses pool_maxsize=10 (requests.adapters.DEFAULT_POOLSIZE)
          adapter = CacheControlAdapter(cache=file_cache, pool_maxsize=10)
          session.mount('http://', adapter)
          session.mount('https://', adapter)

          # Test 1: Simple session.get() with HTML
          url_html = 'https://pypi.org/simple/requests/'
          log('Test 1: session.get() HTML...')
          try:
              r = session.get(url_html, timeout=10)
              log(f'  Result: Status={r.status_code}, Length={len(r.content)}')
          except Exception as e:
              log(f'  Result: FAILED - {type(e).__name__}: {e}')

          # Test 2: Request with JSON Accept header (like Poetry uses)
          log('Test 2: session.get() with JSON Accept header...')
          try:
              headers = {'Accept': 'application/vnd.pypi.simple.v1+json, */*;q=0.1'}
              r = session.get(url_html, timeout=10, headers=headers)
              log(f'  Result: Status={r.status_code}, Length={len(r.content)}, Content-Type={r.headers.get("Content-Type")}')
          except Exception as e:
              log(f'  Result: FAILED - {type(e).__name__}: {e}')

          # Test 3: Prepared request + session.send() with JSON header (exactly like Poetry)
          log('Test 3: Prepared request + session.send() with JSON header...')
          try:
              req = requests.Request('GET', url_html, headers=headers)
              prepared = session.prepare_request(req)

              # Merge environment settings (picks up REQUESTS_CA_BUNDLE)
              settings = session.merge_environment_settings(
                  prepared.url, {}, None, True, None
              )
              log(f'  Merged settings: verify={settings.get("verify")}')

              send_kwargs = {'timeout': 10, 'allow_redirects': True}
              send_kwargs.update(settings)

              r = session.send(prepared, **send_kwargs)
              log(f'  Result: Status={r.status_code}, Length={len(r.content)}')
          except Exception as e:
              log(f'  Result: FAILED - {type(e).__name__}: {e}')

          # Test 4: Multiple rapid prepared requests with FileCache (like Poetry retries)
          log('Test 4: Multiple rapid prepared requests with FileCache...')
          for i in range(6):
              try:
                  req = requests.Request('GET', url_html, headers=headers)
                  prepared = session.prepare_request(req)
                  settings = session.merge_environment_settings(prepared.url, {}, None, True, None)
                  r = session.send(prepared, timeout=5, allow_redirects=True, **settings)
                  log(f'  Request {i+1}: Status={r.status_code}')
              except Exception as e:
                  log(f'  Request {i+1}: FAILED - {type(e).__name__}: {e}')

          # Test 5: New session per request (like Poetry retry with new connections)
          log('Test 5: New session per request (Poetry retry pattern)...')
          for i in range(6):
              try:
                  # Create new session like Poetry does on retry
                  new_session = requests.Session()
                  new_session.headers['User-Agent'] = 'poetry/2.3.1 CPython/3.12.3 Linux/6.11.0-1018-azure'
                  new_adapter = CacheControlAdapter(cache=FileCache(cache_dir), pool_maxsize=10)
                  new_session.mount('http://', new_adapter)
                  new_session.mount('https://', new_adapter)

                  req = requests.Request('GET', url_html, headers=headers)
                  prepared = new_session.prepare_request(req)
                  settings = new_session.merge_environment_settings(prepared.url, {}, None, True, None)
                  r = new_session.send(prepared, timeout=15, allow_redirects=True, **settings)
                  log(f'  Request {i+1}: Status={r.status_code}')
                  new_session.close()
              except Exception as e:
                  log(f'  Request {i+1}: FAILED - {type(e).__name__}: {e}')

          log('Poetry-style HTTP: TESTS COMPLETED')
          POETRY_HTTP_TEST

      - name: Test Poetry (not supported by sfw, but works with transparent proxy)
        run: |
          # Create venv and install poetry
          python3 -m venv /tmp/poetry-venv
          /tmp/poetry-venv/bin/pip install -q poetry

          # Show Poetry version
          /tmp/poetry-venv/bin/poetry --version

          # Debug: Check CA bundle environment
          echo "REQUESTS_CA_BUNDLE=$REQUESTS_CA_BUNDLE"
          echo "SSL_CERT_FILE=$SSL_CERT_FILE"
          ls -la $REQUESTS_CA_BUNDLE || echo "CA file not found"

          # Debug: Test raw requests from poetry venv (to rule out venv-specific issues)
          /tmp/poetry-venv/bin/python -c "
          import requests
          import os
          print('Testing from poetry venv...')
          print('REQUESTS_CA_BUNDLE:', os.environ.get('REQUESTS_CA_BUNDLE'))
          r = requests.get('https://pypi.org/simple/requests/')
          print(f'Raw requests: Status={r.status_code}, Length={len(r.content)}')
          "

          # Create and init project
          mkdir -p /tmp/poetry-test && cd /tmp/poetry-test
          /tmp/poetry-venv/bin/poetry init --no-interaction --name test --dependency requests

          # Try disabling Poetry's HTTP cache to see if CacheControlAdapter is the issue
          export POETRY_EXPERIMENTAL_SYSTEM_GIT_CLIENT=true  # May help with some edge cases

          # Install with very verbose output and --no-cache to disable Poetry's resolver cache
          /tmp/poetry-venv/bin/poetry install --no-root -vvv --no-cache 2>&1 || echo "Poetry install failed"

          # Verify
          /tmp/poetry-venv/bin/poetry run python -c "import requests; print('requests version:', requests.__version__)" || echo "Could not import requests"

      - name: Verify Poetry security check in logs
        if: false  # Skip for now
        run: |
          echo "Checking proxy logs for PyPI security check from Poetry..."
          grep "SECURITY checking pkg:pypi/requests" /tmp/proxy.log || {
            echo "WARNING: No PyPI security check found for requests"
            echo "Checking for any pythonhosted.org traffic..."
          }
          grep "pythonhosted.org\|pypi.org" /tmp/proxy.log | head -10 || echo "(no PyPI requests found)"
          grep "SECURITY checking pkg:pypi" /tmp/proxy.log | head -5 || echo "(no pypi checks found)"

      - name: Show proxy logs
        if: always()
        run: |
          echo "=== Proxy Log ==="
          cat /tmp/proxy.log || echo "No log file found"

      - name: Show mitmproxy internal logs
        if: always()
        run: |
          echo "=== Mitmproxy Internal Log ==="
          cat /tmp/mitmproxy.log 2>/dev/null || echo "No mitmproxy log file found"
